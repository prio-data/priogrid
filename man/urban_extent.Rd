% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data_ghs_wup.R
\name{urban_extent}
\alias{urban_extent}
\title{Extract contiguous urban extent around a location}
\usage{
urban_extent(
  lon,
  lat,
  measurement_date,
  urban_definition = c(21, 22, 23, 30),
  max_extent = 1e+06
)
}
\arguments{
\item{lon}{Numeric. Longitude of the location of interest (WGS84, decimal degrees).}

\item{lat}{Numeric. Latitude of the location of interest (WGS84, decimal degrees).}

\item{measurement_date}{Character. Date for which to extract urban extent,
in format "YYYY-MM-DD" (e.g., "2020-12-31"). Must match one of the available
dates in the GHS-WUP-DEGURBA dataset (typically at 5-year intervals:
1975, 1980, ..., 2030).}

\item{urban_definition}{Numeric vector of DEGURBA codes to classify as urban.
Default is \code{c(21, 22, 23, 30)} (suburban, semi-dense, dense, and urban centres).
Valid codes are: 10, 11, 12, 13, 21, 22, 23, 30. See Details for code meanings.}

\item{max_extent}{Numeric. Maximum search radius in meters around the input
coordinates. Default is 1000000 (1000 km). This limits the area searched
for connected urban patches and improves computational efficiency.}
}
\value{
An \code{sf} polygon object representing the contiguous urban extent
containing the input location. The polygon is returned in the coordinate
reference system specified by \code{pgoptions$get_crs()}. If the input
location is not classified as urban, the function may return an empty
polygon or fail.
}
\description{
Identifies and delineates the contiguous urban extent surrounding a specified
geographic location using GHS-WUP-DEGURBA (Degree of Urbanisation) data.
The function extracts the urban patch that contains the input coordinates,
providing a polygon boundary of the connected urban area.
}
\details{
The function performs the following workflow:
\enumerate{
\item Creates a circular buffer of radius \code{max_extent} around the input coordinates
\item Extracts GHS-WUP-DEGURBA data for the specified \code{measurement_date}
\item Crops the raster to the buffer area for computational efficiency
\item Reclassifies cells to binary urban (1) or non-urban (0) based on \code{urban_definition}
\item Identifies all contiguous urban patches using 8-directional connectivity
\item Determines which patch contains the input coordinates
\item Extracts and dissolves the contiguous urban patch into a single polygon
}

The DEGURBA classification codes represent:
\itemize{
\item 30: Urban centres (cities)
\item 23: Dense urban cluster
\item 22: Semi-dense urban cluster
\item 21: Suburban or peri-urban
\item 13: Rural cluster
\item 12: Low density rural
\item 11: Very low density rural
\item 10: Water bodies or uninhabited areas
}

\strong{Contiguity}: Urban patches are defined using 8-directional connectivity,
meaning cells are considered connected if they share an edge or corner.
}
\note{
\itemize{
\item The function requires the input coordinates to fall within an urban area
\item Larger \code{max_extent} values increase computational time and memory usage
\item The urban definition significantly affects the resulting extent
\item Stricter definitions (e.g., only code 30) produce smaller extents
\item Broader definitions (e.g., codes 21-30) produce larger extents
\item Processing time varies with the size of the urban area
}
}
\examples{
\dontrun{
# Extract urban extent for Oslo, Norway (2020)
oslo_extent <- urban_extent(
  lon = 10.763063,
  lat = 59.935320,
  measurement_date = "2020-12-31"
)

# Plot the result
plot(sf::st_geometry(oslo_extent), main = "Oslo Urban Extent 2020")

# Extract urban extent for New Delhi, India (2020)
delhi_extent <- urban_extent(
  lon = 77.231487,
  lat = 28.612738,
  measurement_date = "2020-12-31"
)

# Compare urban extent over time for the same location
paris_1975 <- urban_extent(
  lon = 2.3522,
  lat = 48.8566,
  measurement_date = "1975-12-31"
)
paris_2020 <- urban_extent(
  lon = 2.3522,
  lat = 48.8566,
  measurement_date = "2020-12-31"
)

# Calculate urban area expansion
area_1975 <- sf::st_area(paris_1975)
area_2020 <- sf::st_area(paris_2020)
expansion <- (area_2020 - area_1975) / area_1975 * 100
cat("Urban expansion:", round(expansion, 1), "\%\n")

# Use stricter urban definition (only urban centres)
tokyo_core <- urban_extent(
  lon = 139.6917,
  lat = 35.6895,
  measurement_date = "2020-12-31",
  urban_definition = 30
)

# Use broader urban definition (including all urbanized areas)
tokyo_metro <- urban_extent(
  lon = 139.6917,
  lat = 35.6895,
  measurement_date = "2020-12-31",
  urban_definition = c(21, 22, 23, 30)
)

# Reduce search radius for smaller cities
kongsvinger <- urban_extent(
  lon = 12.000669,
  lat = 60.190700,
  measurement_date = "2020-12-31",
  max_extent = 50e3  # 50 km radius
)

# Extract multiple cities and compare
cities <- data.frame(
  name = c("London", "Paris", "Berlin"),
  lon = c(-0.1276, 2.3522, 13.4050),
  lat = c(51.5074, 48.8566, 52.5200)
)

city_extents <- lapply(1:nrow(cities), function(i) {
  urban_extent(
    lon = cities$lon[i],
    lat = cities$lat[i],
    measurement_date = "2020-12-31"
  )
})

# Calculate areas
city_areas <- sapply(city_extents, sf::st_area)
cities$area_km2 <- as.numeric(city_areas) / 1e6
print(cities)
}

}
\references{
\insertRef{schiavinaGHSWUPDEGURBAR2025AGHSWUP2025}{priogrid}

\insertRef{europeancommissionApplyingDegreeUrbanisation2021}{priogrid}
}
\seealso{
\code{\link{read_ghs_wup_degurba}} for reading the underlying DEGURBA data

\code{\link{ghs_wup_degurba}} for custom urban classification
}
