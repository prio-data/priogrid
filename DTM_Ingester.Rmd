---
title: "DTM Data Ingestion"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
# install.packages("dtmapi")
```


```{r}
# Reference libraries:
library(httr)
library(jsonlite)
library(dtmapi)
library(dplyr)
library(purrr)
library(tibble)

```

First we will generate a dataframe the presents a complete inventory of countries which DTM provides data.
```{r}
countries_df <- get_all_countries()
```

After retrieving this data, we understand that the IOM supports DTM data for 56 countries.
```{r}
head(countries_df)
print(paste('There are', nrow(countries_df), 'countries available'))
```
Now, in order to iterate over each country to query and interact with the DTM data we will translate this dataframe of countries into a list.

```{r}
countryname_list <- as.list(unique(countries_df$admin0Name))
print(countryname_list)
admin0_list <- as.list(unique(countries_df$admin0Pcode))
#print(admin0_list)
```
```{r}
admin0 = get_idp_admin2_data(CountryName = 'Philippines (the)')
head(admin0)

for (country in countryname_list) {
  print(country)
}

```


From this list we are now set up to begin (re)constructing a metadata table that can be referenced: https://dtm.iom.int/data-and-analysis/dtm-api/data-coverage. Building this systematically within this repository affords autonomy and operability to interact with additional information for each country and define specific queries in later steps.

To pilot this, we will first generate a subset of the last three countries (Yemen, Zambia, and Zimbabwe), to iterate over.

```{r}
last_3_countries <- tail(countryname_list, 3)
print(last_3_countries)
```
We are now generating a master dictionary to organize the relevant country level data for bespoke processes.

```{r}
master_country_assessment_dict <- list()
```

Returns ADM0 level data

```{r}
# Example list of countries
# Assume last_3_countries is already defined (e.g., ["Yemen", "Somalia", "Ethiopia"])
for (country in countryname_list) {
  cat("Fetching data for:", country, "\n")
  
  # Step 1: Get the data
  result <- get_idp_admin0_data(CountryName = country)
  
  # Step 2: Assign individual country data frame (e.g., idp_admin0_Yemen)
  df_name <- paste0("idp_admin0_", gsub(" ", "_", country))
  assign(df_name, result)
  
  # Step 3: Create the country-level dictionary
  if (!is.null(result) && nrow(result) > 0 && "assessmentType" %in% colnames(result)) {
    country_dict <- result %>%
      group_by(assessmentType) %>%
      summarise(
        roundNumber = list(roundNumber),
        yearReportingDate = list(yearReportingDate),
        .groups = "drop"
      )
    
    country_dict_list <- setNames(
      lapply(1:nrow(country_dict), function(i) {
        list(
          roundNumber = country_dict$roundNumber[[i]],
          yearReportingDate = country_dict$yearReportingDate[[i]]
        )
      }),
      country_dict$assessmentType
    )
    
    # Step 4: Add to master_dict
    master_country_assessment_dict[[country]] <- country_dict_list
  } else {
    message("No valid data or missing 'assessmentType' for: ", country)
  }
}


```


```{r}
safe_get_idp_data <- function(level, country_api) {
  tryCatch({
    result <- switch(level,
                     admin0 = get_idp_admin0_data(CountryName = country_api),
                     admin1 = get_idp_admin1_data(CountryName = country_api),
                     admin2 = get_idp_admin2_data(CountryName = country_api))
    
    if (is.null(result) || nrow(result) == 0) {
      message("  ‚ö†Ô∏è No data returned for ", country_api, " at ", level)
      return(NULL)
    }
    
    return(result)
  }, error = function(e) {
    message("  ‚ùå API error for ", country_api, " at ", level, ": ", conditionMessage(e))
    return(NULL)
  })
}

```



```{r}
# Define admin levels to process
admin_levels <- c("admin0", "admin1", "admin2")  # Only include admin2 if supported

# Initialize master dictionary
master_assessment_dict <- list()

# Main loop through countries and levels
for (country in countryname_list) {
  cat("\nüåç Fetching data for:", country, "\n")
  
  # Convert underscore country name to API-compatible format
  #country_api <- gsub("", "_", country)

  
  for (level in admin_levels) {
    cat("  ‚ñ∂Ô∏è Admin level:", level, "\n")
    
    # Step 1: Safely get data
    result <- safe_get_idp_data(level, country)
    
    # Step 2: If result is NULL, move on
    if (is.null(result)) {
      if (level == "admin2") {
        message("  ‚è© Skipping to next country after admin2 attempt.")
        break  # Exit admin level loop, go to next country
      } else {
        next  # Move to next level (admin1 or admin2)
      }
    }

    # Step 3: Continue with data processing (your full validation, Result saving, etc.)
    round_info <- result %>%
      dplyr::select(assessmentType, roundNumber, yearReportingDate) %>%
      dplyr::distinct()

    invalid_rounds <- round_info %>%
      dplyr::group_by(assessmentType, roundNumber) %>%
      dplyr::summarise(count = dplyr::n_distinct(yearReportingDate), .groups = "drop") %>%
      dplyr::filter(count > 1)

    if (nrow(invalid_rounds) > 0) {
      warning("‚ùó Some roundNumbers have multiple yearReportingDate values for ", country, " at ", level, ":\n",
              paste(capture.output(print(invalid_rounds)), collapse = "\n"))
    }

    country_dict <- round_info %>%
      dplyr::group_by(assessmentType) %>%
      dplyr::summarise(
        roundNumber = list(unique(roundNumber)),
        yearReportingDate = list(yearReportingDate[!duplicated(roundNumber)]),
        .groups = "drop"
      )

    country_dict_list <- setNames(
      lapply(1:nrow(country_dict), function(i) {
        list(
          roundNumber = country_dict$roundNumber[[i]],
          yearReportingDate = country_dict$yearReportingDate[[i]]
        )
      }),
      country_dict$assessmentType
    )

    country_dict_list[["Result"]] <- result

    if (is.null(master_assessment_dict[[level]])) {
      master_assessment_dict[[level]] <- list()
    }
    
    master_assessment_dict[[level]][[country]] <- country_dict_list
  }
}



```


```{r}
# Initialize lists to hold combined rows for each level
adm0_rows <- list()
adm1_rows <- list()
adm2_rows <- list()

# Define the fields you want per admin level
adm_fields <- list(
  admin0 = c("admin0Name", "admin0Pcode", "reportingDate", "numPresentIdpInd"),
  admin1 = c("admin0Name", "admin0Pcode", "admin1Name", "admin1Pcode", "reportingDate", "numPresentIdpInd"),
  admin2 = c("admin0Name", "admin0Pcode", "admin2Name", "admin2Pcode", "reportingDate", "numPresentIdpInd")
)


# Iterate over the levels
for (level in names(master_assessment_dict)) {
  level_data <- master_assessment_dict[[level]]
  
  for (country in names(level_data)) {
    result_df <- level_data[[country]]$Result
    
    if (!is.null(result_df) && nrow(result_df) > 0) {
      # Subset to the required fields if available
      fields_to_keep <- adm_fields[[level]]
      available_fields <- intersect(fields_to_keep, colnames(result_df))
      
      cleaned_df <- result_df[, available_fields, drop = FALSE]
      
      # Store by level
      if (level == "admin0") {
        adm0_rows[[length(adm0_rows) + 1]] <- cleaned_df
      } else if (level == "admin1") {
        adm1_rows[[length(adm1_rows) + 1]] <- cleaned_df
      } else if (level == "admin2") {
        adm2_rows[[length(adm2_rows) + 1]] <- cleaned_df
      }
    }
  }
}

# Combine all rows into final data frames
adm0_df <- dplyr::bind_rows(adm0_rows)
adm1_df <- dplyr::bind_rows(adm1_rows)
adm2_df <- dplyr::bind_rows(adm2_rows)
```

```{r}
print(list(unique(adm1_df$admin0Name)))
```

Search for the appropriate admin data to associate to country IOM datasets:

```{r}
library(httr)
library(jsonlite)

# Function to search HDX and print available resources for a country
search_admin_layers <- function(country_query) {
  
  # Set API base
  base_url <- "https://data.humdata.org/api/3/action/package_search"
  
  # Set query
  query_params <- list(q = paste0(country_query, " administrative boundaries"))
  
  # Make request
  response <- GET(base_url, query = query_params)
  
  # Parse
  response_content <- content(response, as = "text")
  response_json <- fromJSON(response_content, flatten = TRUE)
  
  # Extract datasets
  datasets <- response_json$result$results
  
  # Print datasets
  if (nrow(datasets) > 0) {
    for (i in seq_len(nrow(datasets))) {
      cat(paste0("\nDataset ", i, ": ", datasets$title[i], "\n"))
      cat(paste0("   ID: ", datasets$id[i], "\n"))
      
      # Now print available resources
      resources <- datasets$resources[[i]]
      
      for (j in seq_len(nrow(resources))) {
        cat(paste0("     Resource ", j, ": ", resources$name[j], "\n"))
        cat(paste0("       Format: ", resources$format[j], "\n"))
        cat(paste0("       URL: ", resources$url[j], "\n"))
      }
    }
  } else {
    cat("No datasets found for this query.\n")
  }
}

# Example use
search_admin_layers("Afghanistan")


```



```{r}
library(sf)

# Read the shapefile
fewsnet_admin2 <- st_read("/Users/gbenz/Documents/FEWSNET Backup/FEWSnet/FEWSNET_World_Admin/FEWSNET_Admin2.shp")
fewsnet_admin1 <- st_read("/Users/gbenz/Documents/FEWSNET Backup/FEWSnet/FEWSNET_World_Admin/FEWSNET_Admin1.shp")


# Subset Afghanistan to compare fewsnet shapefile with IPC admin field codes:
afghanistan_admin1 <- fewsnet_admin1[fewsnet_admin1$ADMIN0 == "Afghanistan", ]
print('printing FEWSNET ADMIN LAYER: ')
# See all field (column) names
afghanistan_iom = adm1_df[adm1_df$admin0Name == 'Afghanistan',]
```

```{r}
View(afghanistan_iom)

View(afghanistan_admin1)
```


## Lets investigate what attributes are available within the Admin 1 product for Yemen:

```{r}
# Extract the vector
roundNumber <- master_country_assessment_dict[["Yemen"]][["BA"]][["roundNumber"]]

# Get min and max
min_rn <- min(roundNumber, na.rm = TRUE)
max_rn <- max(roundNumber, na.rm = TRUE)

cat("Earliest reporting number:", min_rn, "\n")
cat("Latest reporting number:", max_rn, "\n")

```






