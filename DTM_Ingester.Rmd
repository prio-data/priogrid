---
title: "DTM Data Ingestion"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
# install.packages("dtmapi")
```


```{r}
# Reference libraries:
library(httr)
library(jsonlite)
library(dtmapi)
library(dplyr)
library(purrr)
library(tibble)

```

First we will generate a dataframe the presents a complete inventory of countries which DTM provides data.
```{r}
countries_df <- get_all_countries()
```

After retrieving this data, we understand that the IOM supports DTM data for 56 countries.
```{r}
head(countries_df)
print(paste('There are', nrow(countries_df), 'countries available'))
```
Now, in order to iterate over each country to query and interact with the DTM data we will translate this dataframe of countries into a list.

```{r}
countryname_list <- as.list(unique(countries_df$admin0Name))
print(countryname_list)
admin0_list <- as.list(unique(countries_df$admin0Pcode))
#print(admin0_list)
```

From this list we are now set up to begin (re)constructing a metadata table that can be referenced: https://dtm.iom.int/data-and-analysis/dtm-api/data-coverage. Building this systematically within this repository affords autonomy and operability to interact with additional information for each country and define specific queries in later steps.

To pilot this, we will first generate a subset of the last three countries (Yemen, Zambia, and Zimbabwe), to iterate over.

```{r}
last_3_countries <- tail(countryname_list, 3)
print(last_3_countries)
```
We are now generating a master dictionary to organize the relevant country level data for bespoke processes.

```{r}
master_country_assessment_dict <- list()
```

```{r}
head(idp_admin0_Yemen)
```

Returns ADM0 level data

```{r}
# Example list of countries
# Assume last_3_countries is already defined (e.g., ["Yemen", "Somalia", "Ethiopia"])
for (country in last_3_countries) {
  cat("Fetching data for:", country, "\n")
  
  # Step 1: Get the data
  result <- get_idp_admin0_data(CountryName = country)
  
  # Step 2: Assign individual country data frame (e.g., idp_admin0_Yemen)
  df_name <- paste0("idp_admin0_", gsub(" ", "_", country))
  assign(df_name, result)
  
  # Step 3: Create the country-level dictionary
  if (!is.null(result) && nrow(result) > 0 && "assessmentType" %in% colnames(result)) {
    country_dict <- result %>%
      group_by(assessmentType) %>%
      summarise(
        roundNumber = list(roundNumber),
        yearReportingDate = list(yearReportingDate),
        .groups = "drop"
      )
    
    country_dict_list <- setNames(
      lapply(1:nrow(country_dict), function(i) {
        list(
          roundNumber = country_dict$roundNumber[[i]],
          yearReportingDate = country_dict$yearReportingDate[[i]]
        )
      }),
      country_dict$assessmentType
    )
    
    # Step 4: Add to master_dict
    master_country_assessment_dict[[country]] <- country_dict_list
  } else {
    message("No valid data or missing 'assessmentType' for: ", country)
  }
}


```



```{r}
# Define admin levels to process
admin_levels <- c("admin0", "admin1", "admin2")  # Only include admin2 if supported

# Initialize master dictionary
master_assessment_dict <- list()

# Loop through countries and levels
for (country in last_3_countries) {
  cat("\nüåç Fetching data for:", country, "\n")
  
  for (level in admin_levels) {
    cat("  ‚ñ∂Ô∏è Admin level:", level, "\n")
    
    # Step 1: Pull data using the correct function
    result <- switch(level,
                     admin0 = get_idp_admin0_data(CountryName = country),
                     admin1 = get_idp_admin1_data(CountryName = country),
                     admin2 = get_idp_admin2_data(CountryName = country))
    
    # Step 2: Check for valid result
    if (!is.null(result) && nrow(result) > 0 && "assessmentType" %in% colnames(result)) {
      
      # Step 3: Clean and validate round-to-year mapping
      round_info <- result %>%
        select(assessmentType, roundNumber, yearReportingDate) %>%
        distinct()
      
      # Check for invalid roundNumber ‚Üí yearReportingDate mappings
      invalid_rounds <- round_info %>%
        group_by(assessmentType, roundNumber) %>%
        summarise(count = n_distinct(yearReportingDate), .groups = "drop") %>%
        filter(count > 1)
      
      if (nrow(invalid_rounds) > 0) {
        warning("‚ùó Some roundNumbers have multiple yearReportingDate values for ", country, " at ", level, ":\n",
                paste(capture.output(print(invalid_rounds)), collapse = "\n"))
      }
      
      # Step 4: Build summary dictionary (1-to-1 round ‚Üí year mapping)
      country_dict <- round_info %>%
        group_by(assessmentType) %>%
        summarise(
          roundNumber = list(unique(roundNumber)),
          yearReportingDate = list(yearReportingDate[!duplicated(roundNumber)]),
          .groups = "drop"
        )
      
      # Step 5: Convert to named list-of-lists by assessmentType
      country_dict_list <- setNames(
        lapply(1:nrow(country_dict), function(i) {
          list(
            roundNumber = country_dict$roundNumber[[i]],
            yearReportingDate = country_dict$yearReportingDate[[i]]
          )
        }),
        country_dict$assessmentType
      )
      
      # Step 6: Add full result table to the same list
      country_dict_list[["Result"]] <- result
      
      # Step 7: Save into master dictionary
      if (is.null(master_assessment_dict[[level]])) {
        master_assessment_dict[[level]] <- list()
      }
      master_assessment_dict[[level]][[country]] <- country_dict_list
      
    } else {
      message("  ‚ö†Ô∏è No valid data or missing 'assessmentType' for: ", country, " at ", level)
    }
  }
}



```


```{r}
# Initialize lists to hold combined rows for each level
adm0_rows <- list()
adm1_rows <- list()
adm2_rows <- list()

# Define the fields you want per admin level
adm_fields <- list(
  admin0 = c("admin0Name", "admin0Pcode", "reportingDate", "numPresentIdpInd"),
  admin1 = c("admin0Name", "admin0Pcode", "admin1Name", "admin1Pcode", "reportingDate", "numPresentIdpInd"),
  admin2 = c("admin0Name", "admin0Pcode", "admin2Name", "admin2Pcode", "reportingDate", "numPresentIdpInd")
)

# Iterate over the levels
for (level in names(master_assessment_dict)) {
  level_data <- master_assessment_dict[[level]]
  
  for (country in names(level_data)) {
    result_df <- level_data[[country]]$Result
    
    if (!is.null(result_df) && nrow(result_df) > 0) {
      # Subset to the required fields if available
      fields_to_keep <- adm_fields[[level]]
      available_fields <- intersect(fields_to_keep, colnames(result_df))
      
      cleaned_df <- result_df[, available_fields, drop = FALSE]
      
      # Store by level
      if (level == "admin0") {
        adm0_rows[[length(adm0_rows) + 1]] <- cleaned_df
      } else if (level == "admin1") {
        adm1_rows[[length(adm1_rows) + 1]] <- cleaned_df
      } else if (level == "admin2") {
        adm2_rows[[length(adm2_rows) + 1]] <- cleaned_df
      }
    }
  }
}

# Combine all rows into final data frames
adm0_df <- dplyr::bind_rows(adm0_rows)
adm1_df <- dplyr::bind_rows(adm1_rows)
adm2_df <- dplyr::bind_rows(adm2_rows)
```

## Lets investigate what attributes are available within the Admin 1 product for Yemen:

```{r}
# Extract the vector
roundNumber <- master_country_assessment_dict[["Yemen"]][["BA"]][["roundNumber"]]

# Get min and max
min_rn <- min(roundNumber, na.rm = TRUE)
max_rn <- max(roundNumber, na.rm = TRUE)

cat("Earliest reporting number:", min_rn, "\n")
cat("Latest reporting number:", max_rn, "\n")

```

Now we pull the data from the API using these values:





